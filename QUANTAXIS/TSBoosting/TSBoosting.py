import argparse #This package is used to read in arguments from command line.
import configparser #This package is used to read in configuration files
import pandas as pd
import xgboost as xgb
import os
import pickle


from QUANTAXIS.QAUtil import QASETTING

from QUANTAXIS.TSFetch.fetchdata import getrawfrommongodb
from QUANTAXIS.TSSU.save_prediction import TS_SU_save_prediction
from QUANTAXIS.TSSU import save_rawdata


config = configparser.ConfigParser(interpolation=configparser.ExtendedInterpolation())
config.read('./QUANTAXIS/TSBoosting/config.ini')

'''
get arguments from cli, run:
python3 setup.py install
python3  timeseriesfcst -c /Users/you/Desktop/timeseriesfcst_config/config.ini

# create a new argument parser
parser = argparse.ArgumentParser(description="Simple argument parser")
# add a new command line option, call it '-c' and set its destination to 'config'
parser.add_argument("-c", action="store", dest="config_file")
# get the result
result = parser.parse_args()

# read configuration from configuration file.
config = configparser.ConfigParser()
config.read(result.config_file)
'''






# def readdata(path):
#     '''This function reads in a data frame with index 'dtindex' from a specified path.
#         Args:
#             path: a path that specifies the location of the data.
#         Returns:
#             A data frame indexed with standard datetime index. The column name of that index must be dtindex.
#     '''
#
#     data = pd.read_csv(path)
#     data.index = data['dtindex']
#
#     return data.drop(columns='dtindex')



def fillinmissing(data, dtindex, fillin=None, indicator=False):
    '''This function takes a data frame that is indexed by standard datetime index.
    It completes the data frame by encoding values to missing records.
        Args:
            data: a data frame that is indexed by datetime index with missing records to be filled in.
            dtindex: a full datetime index list as a reference to locate the missing records.
            fillin: indicate what value should be filled in.
            indicator: if is True. The function will add an additional column indicts which row is newly filled in.
        Returns:
            A data frame without missing records.
    '''
    fulldata = pd.DataFrame(index=dtindex)
    fulldata = fulldata.join(data)

    if indicator is True:
        ismissing = pd.notna(fulldata)
        fulldata = fulldata.fillna(fillin)
        return fulldata, ismissing

    return fulldata



def get_lag(data, lags, unit, period):
    lagdata_output = pd.DataFrame(index=data.shift(period, freq=unit).index)

    for lag in lags:
        # print("lagdata before shift")
        # print(data)
        lagdata = data.shift(lag, freq=unit)
        # print("lagdata after shift")
        # print(lagdata)
        lagdatanames = [colname + "lag" + str(lag) + unit for colname in data.columns]
        # print(lagdatanames)
        # print("########################")
        lagdata.columns = lagdatanames
        lagdata_output = lagdata_output.join(lagdata)
    return lagdata_output.dropna()




def get_lag_mean(data, lags, unit, meanby):
    lagdata_output = pd.DataFrame(index=data.index)
    for lag in lags:
        lagdata = data.shift(lag, freq=unit).groupby(pd.Grouper(freq=meanby)).transform('mean')
        lagdatanames = [colname + "lag" + str(lag) + unit + 'meanby' + meanby for colname in data.columns]
        lagdata.columns = lagdatanames
        lagdata_output = lagdata_output.join(lagdata)
    return lagdata_output

def gettimefeature(uniquedtseq):
    '''Get predictors generated by time
        Args:
            uniquekey: a list of datetimes
        Returns:
            A data frame that contains predictors generated by time.(Hour and DayofWeek)
    '''
    timefeature = pd.DataFrame(index = uniquedtseq)
    timefeature['Hour'] = uniquedtseq.hour
    timefeature['DayofWeek'] = uniquedtseq.weekday
    timefeature = pd.get_dummies(timefeature, prefix=['Hour', 'DayofWeek'], columns=['Hour', 'DayofWeek'])
    return timefeature






class XGBInput(object):
    def __init__(self, label, covariate, splitdt):
        self.label = label
        self.covariate = covariate

        self.labeltrain = self.label.loc[self.label.index <= splitdt].copy()
        self.covariatetrain = self.covariate.loc[self.covariate.index <= splitdt].copy()

        self.labeltest = self.label.loc[self.label.index > splitdt].copy()
        self.covariatetest = self.covariate.loc[self.covariate.index > splitdt].copy()
        self.ddata = xgb.DMatrix(self.covariate, label=self.label)

        self.dtrain = xgb.DMatrix(self.covariatetrain, label=self.labeltrain)
        self.trainindex = self.covariatetrain.index
        self.dtest = xgb.DMatrix(self.covariatetest, label=self.labeltest)
        self.testindex = self.covariatetest.index
        self.evallist = [(self.dtest, 'eval'), (self.dtrain, 'train')]

        self.dtraintest = xgb.DMatrix(covariate, label=label)
        self.traintestindex = covariate.index
        print("label: " + str(self.label))
        print("label train: "+ str(self.labeltrain))


    def gettrain(self):
        return self.dtrain

    def gettest(self):
        return self.dtest



def TS_Boosting_predict(start,end,by,databaseid,collectionid):
    print('Start boosting...')
    dtindex = pd.date_range(start=start,
                            end=end,
                            freq=by)


    rawdata = getrawfrommongodb(start=start, end=end,
                                databaseid=databaseid, collectionid=collectionid)
    outcome = rawdata.data
    outcome.set_index('datetime', inplace=True)

    outcome, isencoded = fillinmissing(data=outcome,
                                     dtindex=dtindex,
                                     fillin=0,
                                     indicator=True)
    # predictors = pd.DataFrame(index=dtindex)
    #
    #
    # for i in config['predictorspath']:
    #     predictor = readdata(config['predictorspath'][i])
    #
    #     predictor = fillinmissing(data=predictor,
    #                                        dtindex=dtindex,
    #                                        fillin=None)
    #     predictors = predictors.join(predictor)

    outcomelag = get_lag(data=outcome, lags=range(14, 30), unit='D',period =14)

    #outcomelagmean = get_lag_mean(data=outcome, lags=range(14, 60), unit='D', meanby='D')

    # predictorslag = get_lag(data=predictors, lags=range(1, 10), unit='D')
    # predictorslagmean = get_lag_mean(data=predictors, lags=range(1, 10), unit='D', meanby='D')
    #
    # predictorslaglagbyh = get_lag(data=predictors, lags=range(1, 5), unit='H')

    #datetimefeature = gettimefeature(dtindex)

    #featurelist = [outcomelag, outcomelagmean, predictorslag, predictorslagmean, datetimefeature]
    #fullfeature = pd.concat(featurelist, axis=1)

    fulllist = [outcome, outcomelag]
    #print(fulllist)
    fulldf = pd.concat(fulllist, axis=1).dropna()
    #print(fulldf['y'])
    forecastdf = pd.concat(fulllist, axis=1).iloc[-14:, 1:]
    print("forecase dataframe...")
    print(forecastdf)

    splitpoint = int(0.99 * len(dtindex))
    splitdt = str(dtindex[splitpoint])
    xgbinpt = XGBInput(label=fulldf['y'], covariate=fulldf.drop(columns='y'), splitdt=splitdt)


    param = {
        'max_depth': 2,
        'eta': .005,
        'silent': 1,
        'objective': 'reg:squarederror',
        'nthread': 5,
        'eval_metric': 'rmse'
    }


    numround =3000
    # from pandas.plotting import register_matplotlib_converters
    # register_matplotlib_converters()

    print("xgbinpt.dtrain")
    print(xgbinpt.dtrain)

    xgbmod = xgb.train(param, xgbinpt.dtrain, numround, xgbinpt.evallist, early_stopping_rounds=10)

    # filename = config['modelpath']['path']+'Store' + str(12) + '.model'
    # os.makedirs(os.path.dirname(filename), exist_ok=True)

    # with open(filename, "wb") as f:
    #     pickle.dump(xgbmod, f)


    #prediction =pd.DataFrame(xgbinpt.label)
    # print(prediction)
    prediction = pd.DataFrame(xgbmod.predict(xgb.DMatrix(forecastdf)), index=forecastdf.index)
    prediction.columns = ['predict']
    # print(prediction2)
    #prediction = prediction.join(prediction2)
    # print(prediction)
    # print(dtindex)
    prediction['datetime'] = forecastdf.index

    past_prediction = {'predict': xgbmod.predict(xgbinpt.dtrain), 'y_t':xgbinpt.labeltrain}

    past_prediction = pd.DataFrame(past_prediction, index=xgbinpt.labeltrain.index)

    past_prediction['datetime'] = past_prediction.index

    TS_SU_save_prediction(name='past_prediction', prediction=past_prediction, client=QASETTING.client, ui_log=None)

    TS_SU_save_prediction(name='prediction', prediction=prediction, client=QASETTING.client, ui_log=None)

    #TS_SU_save_prediction(name='past', prediction=past, client=QASETTING.client, ui_log=None)

